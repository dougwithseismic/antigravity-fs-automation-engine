# Antigravity Engine

The **Antigravity Engine** is a powerful, graph-based workflow orchestration engine designed for hybrid execution environments. It seamlessly manages state across server-side logic and client-side interactions.

## Key Features

-   **Graph-Based Execution**: Workflows are defined as directed graphs of nodes and edges.
-   **Hybrid Execution ("Hot Potato")**: Execution can suspend on the server, hand off to a client (browser/device), and resume on the server with the result.
-   **Stateful & Resumable**: Every step is persisted. Workflows can be paused for days (e.g., waiting for human approval) and resumed without data loss.
-   **Idempotency**: Re-running a completed step returns the cached result, ensuring safety.

## Architecture

The engine operates on a `Workflow` definition and creates `Execution` instances.

### Workflow Definition
A JSON structure defining `nodes` and `edges`.

```json
{
  "nodes": [
    { "id": "1", "type": "start" },
    { "id": "2", "type": "condition", "data": { ... } }
  ],
  "edges": [
    { "source": "1", "target": "2" }
  ]
}
```

### Execution Flow
1.  **Start**: `POST /workflows/{id}/execute`
2.  **Traversal**: The engine traverses the graph (BFS).
3.  **Execution**: Each node is executed by a registered `NodeExecutor`.
4.  **Suspension**: If a node returns `status: 'suspended'`, the engine halts and saves state.
5.  **Resumption**: `POST /executions/{id}/resume` continues execution from the suspended node.

## Node Types & Reference

The engine supports a variety of node types. Each node type has a specific purpose and data requirement.

### `start`
-   **Purpose**: The entry point of the workflow.
-   **Execution**: Immediate.
-   **Output**: Passes the initial workflow input to the next node.

### `condition`
-   **Purpose**: Branching logic based on data.
-   **Schema**:
    ```typescript
    z.object({
      condition: z.object({
        key: z.string(),
        value: z.string(),
        operator: z.enum(['equals', 'contains']).optional() // defaults to equals
      })
    })
    ```
-   **Behavior**: Evaluates `input[key] === value`. Returns `{ result: true/false }`.

### `banner-form` (Client)
-   **Purpose**: Displays a banner with a form to the user.
-   **Environment**: `client`
-   **Schema**:
    ```typescript
    z.object({
      label: z.string(),
      message: z.string()
    })
    ```
-   **Behavior**: Suspends execution. The client application renders the banner. When the user submits, the client calls `resumeExecution` with the form data.

### `analytics`
-   **Purpose**: Server-side logging of events.
-   **Schema**:
    ```typescript
    z.object({
      eventName: z.string()
    })
    ```
-   **Behavior**: Logs the event to the console/database.

### `discount`
-   **Purpose**: Generates a discount code.
-   **Schema**:
    ```typescript
    z.object({
      type: z.string().optional(),
      amount: z.number().optional()
    })
    ```
-   **Output**: `{ code: "DISCOUNT_123" }`

### `window-alert` (Client)
-   **Purpose**: Shows a browser alert.
-   **Environment**: `client`
-   **Schema**:
    ```typescript
    z.object({
      message: z.string()
    })
    ```
-   **Behavior**: Suspends execution. Client shows alert. Resumes immediately after acknowledgement.

## Execution Lifecycle & State

### 1. Initialization
When `POST /workflows/{id}/execute` is called:
-   A new `Execution` record is created in the database.
-   The `start` node is identified.

### 2. Traversal
The engine uses a Breadth-First Search (BFS) or topological sort to traverse the graph.
-   **Input Resolution**: Inputs for a node are gathered from the outputs of its parent nodes.

### 3. Node Execution
-   **Server Nodes**: Executed immediately in the Node.js environment.
-   **Client Nodes**: Marked as `suspended`. The execution status becomes `waiting`.

### 4. Suspension (The "Hot Potato")
When a node suspends:
-   The engine stops processing this branch.
-   The state (current node, inputs, outputs so far) is persisted in `execution_steps`.
-   The API returns the `executionId` and the `status: waiting`.

### 5. Resumption
When the client completes the task (e.g., user fills a form):
-   Client calls `POST /executions/{id}/resume`.
-   Payload includes `{ nodeId, output }`.
-   The engine updates the step status to `completed`.
-   Traversal continues from that node's children.

## Idempotency & Caching

The engine is designed to be **idempotent**.
-   Before executing a node, it checks `execution_steps` for an existing `completed` record for that `executionId` and `nodeId`.
-   If found, it **skips execution** and reuses the stored output.
-   This allows you to safely retry workflows or resume them multiple times without side effects (e.g., sending duplicate emails).

