# The Orchestration Engine

The Antigravity engine is built around a simple idea: workflows should be able to pause and wait for input (human or AI) without losing their place.

This is surprisingly hard to do in traditional automation platforms, where everything runs on the server and "pausing" means ending the workflow and starting a new one later.

## What makes this different

### Traditional workflow engines (Make.com, N8N)

- Everything runs on the server
- To wait for user input, workflow must end
- Resume by triggering a new workflow via webhook
- Original context must be reconstructed using correlation IDs
- Complex, fragile, expensive to maintain

### Antigravity's approach

- **Hybrid execution**: Nodes can run on server OR client
- **True pause/resume**: Execution suspends, doesn't end
- **Preserved context**: All variables, data, and state remain intact
- **Clean handoff**: Server orchestrates, client participates

## Core concepts

### Graph-based workflows

Workflows are directed graphs of nodes and edges - just like N8N or Make.com:

```json
{
  "nodes": [
    { "id": "1", "type": "start" },
    { "id": "2", "type": "ai-agent", "data": { ... } },
    { "id": "3", "type": "human-approval", "data": { ... } }
  ],
  "edges": [
    { "source": "1", "target": "2" },
    { "source": "2", "target": "3" }
  ]
}
```

### Hybrid execution (the "hot potato" model)

This is the key innovation. Execution bounces between server and client:

1. Server executes nodes that need backend resources (APIs, database)
2. When a client-side node is reached, execution **suspends**
3. Client SDK receives the workflow state
4. User interacts, provides input
5. Client calls resume endpoint with the data
6. Server picks up where it left off

No webhooks. No correlation IDs. No state reconstruction. Just pause and resume.

### Stateful and resumable

Every step is persisted to the database. This means:
- Workflows can pause for seconds, hours, or days
- If the server crashes, workflow state is intact
- You can inspect execution history at any point
- Re-running a completed step returns cached results (idempotency)

## Architecture

The engine operates on a `Workflow` definition and creates `Execution` instances.

### Workflow Definition
A JSON structure defining `nodes` and `edges`.

```json
{
  "nodes": [
    { "id": "1", "type": "start" },
    { "id": "2", "type": "condition", "data": { ... } }
  ],
  "edges": [
    { "source": "1", "target": "2" }
  ]
}
```

### Execution Flow
1.  **Start**: `POST /workflows/{id}/execute`
2.  **Traversal**: The engine traverses the graph (BFS).
3.  **Execution**: Each node is executed by a registered `NodeExecutor`.
4.  **Suspension**: If a node returns `status: 'suspended'`, the engine halts and saves state.
5.  **Resumption**: `POST /executions/{id}/resume` continues execution from the suspended node.

## Node Types & Reference

The engine supports a variety of node types. Each node type has a specific purpose and data requirement.

### `start`
-   **Purpose**: The entry point of the workflow.
-   **Execution**: Immediate.
-   **Output**: Passes the initial workflow input to the next node.

### `condition`
-   **Purpose**: Branching logic based on data.
-   **Schema**:
    ```typescript
    z.object({
      condition: z.object({
        key: z.string(),
        value: z.string(),
        operator: z.enum(['equals', 'contains']).optional() // defaults to equals
      })
    })
    ```
-   **Behavior**: Evaluates `input[key] === value`. Returns `{ result: true/false }`.

### `banner-form` (Client)
-   **Purpose**: Displays a banner with a form to the user.
-   **Environment**: `client`
-   **Schema**:
    ```typescript
    z.object({
      label: z.string(),
      message: z.string()
    })
    ```
-   **Behavior**: Suspends execution. The client application renders the banner. When the user submits, the client calls `resumeExecution` with the form data.

### `analytics`
-   **Purpose**: Server-side logging of events.
-   **Schema**:
    ```typescript
    z.object({
      eventName: z.string()
    })
    ```
-   **Behavior**: Logs the event to the console/database.

### `discount`
-   **Purpose**: Generates a discount code.
-   **Schema**:
    ```typescript
    z.object({
      type: z.string().optional(),
      amount: z.number().optional()
    })
    ```
-   **Output**: `{ code: "DISCOUNT_123" }`

### `window-alert` (Client)
-   **Purpose**: Shows a browser alert.
-   **Environment**: `client`
-   **Schema**:
    ```typescript
    z.object({
      message: z.string()
    })
    ```
-   **Behavior**: Suspends execution. Client shows alert. Resumes immediately after acknowledgement.

## Execution Lifecycle & State

### 1. Initialization
When `POST /workflows/{id}/execute` is called:
-   A new `Execution` record is created in the database.
-   The `start` node is identified.

### 2. Traversal
The engine uses a Breadth-First Search (BFS) or topological sort to traverse the graph.
-   **Input Resolution**: Inputs for a node are gathered from the outputs of its parent nodes.

### 3. Node Execution
-   **Server Nodes**: Executed immediately in the Node.js environment.
-   **Client Nodes**: Marked as `suspended`. The execution status becomes `waiting`.

### 4. Suspension (The "Hot Potato")
When a node suspends:
-   The engine stops processing this branch.
-   The state (current node, inputs, outputs so far) is persisted in `execution_steps`.
-   The API returns the `executionId` and the `status: waiting`.

### 5. Resumption
When the client completes the task (e.g., user fills a form):
-   Client calls `POST /executions/{id}/resume`.
-   Payload includes `{ nodeId, output }`.
-   The engine updates the step status to `completed`.
-   Traversal continues from that node's children.

## Idempotency & Caching

The engine is designed to be **idempotent**.
-   Before executing a node, it checks `execution_steps` for an existing `completed` record for that `executionId` and `nodeId`.
-   If found, it **skips execution** and reuses the stored output.
-   This allows you to safely retry workflows or resume them multiple times without side effects (e.g., sending duplicate emails).

